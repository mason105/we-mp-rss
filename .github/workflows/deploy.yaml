name: Deploy to Server
on:
  workflow_dispatch:
  # Removed push.tags trigger to prevent race condition
  # Deploy is automatically triggered by build workflow after successful build

jobs:
  Deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout
      uses: actions/checkout@v3
      with:
          fetch-depth: 0

    - name: Get the tag
      id: tag
      run: |
        # Tag Selection Logic:
        # - If triggered from a tag (via "Use workflow from" > Tags tab), deploy that specific tag
        # - If triggered from a branch (via "Use workflow from" > Branches tab), deploy the latest RC tag
        # This allows selective deployment or automatic latest deployment

        if [[ ${GITHUB_REF} == refs/tags/* ]]; then
          # User selected a specific tag from the dropdown
          SELECTED_TAG=${GITHUB_REF#refs/tags/}
          echo "üìå Deploying user-selected tag: $SELECTED_TAG"
        else
          # User selected a branch, auto-detect latest RC tag
          LATEST_RC=$(git tag -l 'RC.*' --sort=-version:refname | head -n1)

          if [ -n "$LATEST_RC" ]; then
            SELECTED_TAG="$LATEST_RC"
            echo "üîÑ Auto-detected latest RC tag: $SELECTED_TAG"
          else
            echo "‚ùå ERROR: No RC tags found in repository"
            echo "Available tags:"
            git tag -l | tail -20
            exit 1
          fi
        fi

        # Validate that the selected tag exists
        if git rev-parse "refs/tags/$SELECTED_TAG" >/dev/null 2>&1; then
          echo "‚úÖ Tag $SELECTED_TAG exists and will be deployed"
          echo "TAG=$SELECTED_TAG" >> $GITHUB_OUTPUT
        else
          echo "‚ùå ERROR: Tag $SELECTED_TAG does not exist in repository"
          echo "Available tags:"
          git tag -l | tail -20
          exit 1
        fi

    - name: Get short SHA
      id: sha
      run: echo "sha7=$( echo $( git show-ref ${{ steps.tag.outputs.TAG }}  | cut -c1-7 ) )" >> $GITHUB_OUTPUT

    - name: Deploy
      uses: nanjingrd/ssh-deploy-action@master
      id: main
      env:
        SYNCED_RUN_ID: ${{github.run_id}}
        ID_RSA_P: ${{ secrets.VAR_ID_RSA_P }}
        TARGET_KEY: ${{ secrets.VAR_ID_RSA_P }}
        TARGET_HOST: ${{ secrets.TARGET_HOST }}
        TARGET_PORT: ${{ secrets.TARGET_PORT }}
        TARGET_USER: ${{ secrets.TARGET_USER }}
        JUMP_USER: ${{ secrets.JUMP_USER }}
        JUMP_HOST: ${{ secrets.JUMP_HOST }}
        JUMP_KEY: ${{ secrets.VAR_ID_RSA_P }}
        CI_PROJECT_NAME: "we-mp-rss"
        DOCKER_CONTAINER_NAME: "we-mp-rss_CD"
        DOCKER_IMG_NAME: "we-mp-rss"
        DOCKER_IMG_TAG: ${{ steps.sha.outputs.sha7 }}
        CI_COMMIT_REF_NAME: ${{ steps.tag.outputs.TAG }}
        CI_REGISTRY_URL: ${{ secrets.VAR_REGISTRY_URL }}
        REGISTRY_username: ${{ secrets.VAR_REGISTRY_USERNAME }}
        REGISTRY_password: ${{ secrets.VAR_REGISTRY_PASSWORD }}
        # Config secrets for generation on server
        DATABASE_URL: ${{ secrets.DATABASE_URL }}
        SECRET_KEY: ${{ secrets.SECRET_KEY }}
        SLACK_WEBHOOK: ${{ secrets.VAR_SLACK_WEBHOOK_URL }}
        LIC_KEY: ${{ secrets.LIC_KEY }}

        COMMAND: |
          #/bin/bash
          set -ex
          date
          echo "CI_PROJECT_NAME=""${CI_PROJECT_NAME}"
          echo "CI_COMMIT_REF_NAME=""${CI_COMMIT_REF_NAME}"

          mkdir -p /tmp/${CI_PROJECT_NAME}
          cd /tmp/${CI_PROJECT_NAME}

          # Create necessary directories if they don't exist
          mkdir -p /home/daqian/docker/${CI_PROJECT_NAME}/config
          mkdir -p /home/daqian/docker/${CI_PROJECT_NAME}/data
          mkdir -p /home/daqian/docker/${CI_PROJECT_NAME}/data/cache
          mkdir -p /home/daqian/docker/${CI_PROJECT_NAME}/data/pdf
          mkdir -p /home/daqian/docker/${CI_PROJECT_NAME}/data/markdown

          # Ensure config.yaml is a file, not a directory (cleanup edge case)
          if [ -d /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml ]; then
            echo "Config path is a directory, removing it..."
            rm -rf /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml
          fi

          # Generate config.yaml directly on server using environment variables
          echo "Generating production config from environment variables..."
          cat > /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml << 'CONFIGEOF'
          server:
            port: 8001
            mode: release

          database:
            url: ${DATABASE_URL}

          security:
            secret_key: ${SECRET_KEY}

          notifications:
            slack_webhook: ${SLACK_WEBHOOK}

          license:
            key: ${LIC_KEY}
          CONFIGEOF

          # Substitute environment variables in the config file
          export DATABASE_URL SECRET_KEY SLACK_WEBHOOK LIC_KEY
          envsubst < /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml > /tmp/config.tmp
          mv /tmp/config.tmp /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml

          echo "‚úÖ Production config generated successfully"
          echo "Config file first 5 lines:"
          head -5 /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml

          docker login --username=${REGISTRY_username} ${CI_REGISTRY_URL} -p${REGISTRY_password}
          docker pull ${CI_REGISTRY_URL}/mason105/${DOCKER_IMG_NAME}:${DOCKER_IMG_TAG}
          docker rm $( docker stop $( docker update --restart=no  $( docker ps -a -q --filter name=${DOCKER_CONTAINER_NAME}* --format='{{.ID}}'))) || true

          docker run  -itd  --name=${DOCKER_CONTAINER_NAME}_${CI_COMMIT_REF_NAME} --restart=always --add-host=host.docker.internal:host-gateway -e TZ=Asia/Shanghai -p 8002:8001 -v /home/daqian/docker/${CI_PROJECT_NAME}/config/config.yaml:/app/config.yaml -v /home/daqian/docker/${CI_PROJECT_NAME}/data:/app/data  ${CI_REGISTRY_URL}/mason105/${DOCKER_IMG_NAME}:${DOCKER_IMG_TAG}

          docker image prune -a -f --filter='label=image_autoclean=true'

        POSTCOMMAND: |
          #/bin/bash
          echo "Deployment completed"
          rm -rf /tmp/${CI_PROJECT_NAME}

    - name: Send Slack notification
      if: always()
      run: |
        if [[ ${{ steps.main.outputs.return_code }} -ne 0 ]]; then
          STATUS="‚ùå FAILED"
          COLOR="#FF0000"
          MESSAGE="Deploy FAILED, please contact admin"
        else
          STATUS="‚úÖ Success"
          COLOR="#36a64f"
          MESSAGE="Deploy succeeded"
        fi

        PAYLOAD=$(cat <<EOF
        {
          "attachments": [
            {
              "color": "${COLOR}",
              "title": "${{ github.event.repository.name }} - Deploy ${STATUS}",
              "fields": [
                {
                  "title": "Status",
                  "value": "${MESSAGE}",
                  "short": true
                },
                {
                  "title": "Return Code",
                  "value": "${{ steps.main.outputs.return_code }}",
                  "short": true
                },
                {
                  "title": "Tag",
                  "value": "${{ steps.tag.outputs.TAG }}",
                  "short": true
                },
                {
                  "title": "Commit",
                  "value": "${{ steps.sha.outputs.sha7 }}",
                  "short": true
                },
                {
                  "title": "Triggered by",
                  "value": "${{ github.actor }}",
                  "short": true
                },
                {
                  "title": "Workflow",
                  "value": "<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Workflow>",
                  "short": true
                }
              ],
              "footer": "GitHub Actions",
              "ts": $(date +%s)
            }
          ]
        }
        EOF
        )

        curl -X POST -H 'Content-type: application/json' \
          --data "${PAYLOAD}" \
          "${{ secrets.VAR_SLACK_WEBHOOK_URL }}"
